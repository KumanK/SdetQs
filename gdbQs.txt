Mediatek
----------
https://linuxhint.com/bash_scripting_interview_questions/

GDB:\
---------------------------------------------------------------------------------------------
g++ -g -o gfg gfg.cpp
run
break [function name]
break [file name]:[line number]
break [line number]
break *[address]
break ***any of the above arguments*** if [condition]
b ***any of the above arguments*** 
info breakpoint

---------------------------------------------------------------------------------------------
(gdb) set args 1 2 3 4
(gdb) show args
(gdb) run
Starting program: /home/kkuman/coding/myFile 1 2 3 4
1
4
9
16
[Inferior 1 (process 3699) exited normally]
---------------------------------------------------------------------------------------------
Setting a Bookmark to Return to Later
	On certain operating systems4, GDB is able to save a snapshot of a program’s state, called a checkpoint, and come back to it later.
	
	Returning to a checkpoint effectively undoes everything that has happened in the program since the checkpoint was saved. This includes changes in memory, registers, and even (within some limits) system state. Effectively, it is like going back in time to the moment when the checkpoint was saved.
	
	Thus, if you’re stepping thru a program and you think you’re getting close to the point where things go wrong, you can save a checkpoint. Then, if you accidentally go too far and miss the critical statement, instead of having to restart your program from the beginning, you can just go back to the checkpoint and start again from there.
	
	This can be especially useful if it takes a lot of time or steps to reach the point where you think the bug occurs.
---------------------------------------------------------------------------------------------
checkpoint for debugging the flows of the program

(gdb) set arg 30 40
(gdb) run
(gdb) break findSquare
Breakpoint 2 at 0x5555555548e1: file temp.cpp, line 8.
(gdb) run
Starting program: /home/kkuman/coding/myFile 30 40

Breakpoint 2, findSquare (a=30) at temp.cpp:8
8           return a * a;
(gdb) checkpoint
checkpoint 1: fork returned pid 32020.
(gdb) info checkpoint
* 0 process 31993 (main process) at 0x5555555548e1, file temp.cpp, line 8
  1 process 32020 at 0x5555555548e1, file temp.cpp, line 8
(gdb) checkpoint
checkpoint 2: fork returned pid 32370.
(gdb) info checkpoint
* 0 process 31993 (main process) at 0x5555555548e1, file temp.cpp, line 8
  1 process 32020 at 0x5555555548e1, file temp.cpp, line 8
  2 process 32370 at 0x5555555548e1, file temp.cpp, line 8
(gdb) restart 0
Switching to process 31993
#0  findSquare (a=30) at temp.cpp:8
8           return a * a;
(gdb) info checkpoint
* 0 process 31993 (main process) at 0x5555555548e1, file temp.cpp, line 8
  1 process 32020 at 0x5555555548e1, file temp.cpp, line 8
  2 process 32370 at 0x5555555548e1, file temp.cpp, line 8
(gdb) restart 2
Switching to process 32370
#0  findSquare (a=30) at temp.cpp:8
8           return a * a;
(gdb) info checkpoint
  0 process 31993 (main process) at 0x5555555548e1, file temp.cpp, line 8
  1 process 32020 at 0x5555555548e1, file temp.cpp, line 8
* 2 process 32370 at 0x5555555548e1, file temp.cpp, line 8
---------------------------------------------------------------------------------------------
Load file symbols into gdb :

(gdb) run
Starting program:
No executable file specified.
Use the "file" or "exec-file" command.
(gdb) file myFile
Reading symbols from myFile...done.
(gdb) run
Starting program: /home/kkuman/coding/myFile
[Inferior 1 (process 2030) exited normally]
(gdb) run 30
Starting program: /home/kkuman/coding/myFile 30
900
[Inferior 1 (process 2035) exited normally]

----------------------------------------------------------------------------------------------
print hex value of a variable

(gdb) print/x a
$2 = 0x14


----------------------------------------

watch point when a value changes:

Breakpoint 5, makeSquare (a=@0x7fffffffe4e0: 33) at watch.cpp:8
8           a= a*a;
(gdb) watch a
Hardware watchpoint 8: a
(gdb) print a
$1 = (int &) @0x7fffffffe4e0: 33
(gdb) continue
Continuing.

Watchpoint 8 deleted because the program has left the block in
which its expression is valid.
main (n=2, args=0x7fffffffe5d8) at watch.cpp:17
17              cout<<a<<endl;
(gdb) print a
$2 = 1089
-----------------------------------------------------------
Back trace to identify seg faults

Breakpoint 9, makeSquare (a=@0x7fffffffe4e0: 70) at watch.cpp:8
8           a= a*a;
(gdb) backtrace
#0  makeSquare (a=@0x7fffffffe4e0: 70) at watch.cpp:8
#1  0x00005555555549c5 in main (n=2, args=0x7fffffffe5d8) at watch.cpp:16
--------------------------------------------------------------------
stepping one line :

Breakpoint 9, makeSquare (a=@0x7fffffffe4e0: 67) at watch.cpp:8
8           a= a*a;
(gdb) step
9       }
(gdb) step
main (n=2, args=0x7fffffffe5d8) at watch.cpp:17
17              cout<<a<<endl;
(gdb) print/x a
$3 = 0x1189
(gdb) print a
$4 = 4489
(gdb) continue
Continuing.
4489
[Inferior 1 (process 17436) exited normally]
(gdb)
-----------------------------------------------------------------------

5. If we have multiple source files, then during the debugging with GDB
a) breakpoint can not be set
b) break point can be set by “break” command with a filename
c) break point can be set only to makefile
d) none of the mentioned


----------------------------------
see the memory

(gdb) x
0x555555554956 <makeSquare(int&)+12>:   0x8b48108b


==================================================
see the source code lines

(gdb) list
13          for (int i = 1; i < n; i++)
14          {
15              int a = atoi(args[i]);
16              makeSquare(a);
17              cout<<a<<endl;
18          }
19          return 0;
20      }
(gdb) list 20
15              int a = atoi(args[i]);
16              makeSquare(a);
17              cout<<a<<endl;
18          }
19          return 0;
20      }
